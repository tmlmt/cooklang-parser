import { createRegex } from "human-regex";

export const metadataRegex = createRegex()
  .literal("---").newline()
  .startCaptureGroup().anyCharacter().zeroOrMore().optional().endGroup()
  .newline().literal("---")
  .dotAll().toRegExp();

export const scalingMetaValueRegex = (varName: string): RegExp => createRegex()
  .startAnchor()
  .literal(varName)
  .literal(":")
  .anyOf("\\t ").zeroOrMore()
  .startCaptureGroup()
    .startCaptureGroup()
      .notAnyOf(",\\n").oneOrMore()
    .endGroup()
    .startGroup()
      .literal(",")
      .whitespace().zeroOrMore()
      .startCaptureGroup()
        .anyCharacter().oneOrMore()
      .endGroup()
    .endGroup().optional()
  .endGroup()
  .endAnchor()
  .multiline()
  .toRegExp()

const nonWordChar = "\\s@#~\\[\\]{(,;:!?"

const multiwordIngredient = createRegex()
  .literal("@")
  .startNamedGroup("mIngredientModifiers")
    .anyOf("@\\-&?").zeroOrMore()
  .endGroup().optional()
  .startNamedGroup("mIngredientRecipeAnchor")
    .literal("./")
  .endGroup().optional()
  .startNamedGroup("mIngredientName")
    .notAnyOf(nonWordChar).oneOrMore()
    .startGroup()
      .whitespace().oneOrMore().notAnyOf(nonWordChar).oneOrMore()
    .endGroup().oneOrMore()
  .endGroup()
  .positiveLookahead("\\s*(?:\\{[^\\}]*\\}|\\([^)]*\\))")
  .startGroup()
    .literal("{")
    .startNamedGroup("mIngredientQuantityModifier")
      .literal("=").exactly(1)
    .endGroup().optional()
    .startNamedGroup("mIngredientQuantity")
      .notAnyOf("}%").oneOrMore()
    .endGroup().optional()
    .startGroup()
      .literal("%")
      .startNamedGroup("mIngredientUnit")
        .notAnyOf("}").oneOrMore().lazy()
      .endGroup()
    .endGroup().optional()
    .literal("}")
  .endGroup().optional()
  .startGroup()
    .literal("(")
    .startNamedGroup("mIngredientPreparation")
      .notAnyOf(")").oneOrMore().lazy()
    .endGroup()
    .literal(")")
  .endGroup().optional()
  .toRegExp();

const singleWordIngredient = createRegex()
  .literal("@")
  .startNamedGroup("sIngredientModifiers")
    .anyOf("@\\-&?").zeroOrMore()
  .endGroup().optional()
  .startNamedGroup("sIngredientRecipeAnchor")
    .literal("./")
  .endGroup().optional()
  .startNamedGroup("sIngredientName")
    .notAnyOf(nonWordChar).oneOrMore()
  .endGroup()
  .startGroup()
    .literal("{")
    .startNamedGroup("sIngredientQuantityModifier")
      .literal("=").exactly(1)
    .endGroup().optional()
    .startNamedGroup("sIngredientQuantity")
      .notAnyOf("}%").oneOrMore()
    .endGroup().optional()
    .startGroup()
      .literal("%")
      .startNamedGroup("sIngredientUnit")
        .notAnyOf("}").oneOrMore().lazy()
      .endGroup()
    .endGroup().optional()
    .literal("}")
  .endGroup().optional()
  .startGroup()
    .literal("(")
    .startNamedGroup("sIngredientPreparation")
      .notAnyOf(")").oneOrMore().lazy()
    .endGroup()
    .literal(")")
  .endGroup().optional()
  .toRegExp();

export const ingredientAliasRegex = createRegex()
  .startAnchor()
  .startNamedGroup("ingredientListName")
    .notAnyOf("|").oneOrMore()
  .endGroup()
  .literal("|")
  .startNamedGroup("ingredientDisplayName")
    .notAnyOf("|").oneOrMore()
  .endGroup()
  .endAnchor()
  .toRegExp();

const multiwordCookware = createRegex()
  .literal("#")
  .startNamedGroup("mCookwareModifiers")
    .anyOf("\\-&?").zeroOrMore()
  .endGroup()
  .startNamedGroup("mCookwareName")
    .notAnyOf(nonWordChar).oneOrMore()
    .startGroup()
      .whitespace().oneOrMore().notAnyOf(nonWordChar).oneOrMore()
    .endGroup().oneOrMore()
  .endGroup().positiveLookahead("\\s*(?:\\{[^\\}]*\\})")
  .literal("{")
  .startNamedGroup("mCookwareQuantity")
    .anyCharacter().zeroOrMore().lazy()
  .endGroup()
  .literal("}")
  .toRegExp();

const singleWordCookware = createRegex()
  .literal("#")
  .startNamedGroup("sCookwareModifiers")
    .anyOf("\\-&?").zeroOrMore()
  .endGroup()
  .startNamedGroup("sCookwareName")
    .notAnyOf(nonWordChar).oneOrMore()
  .endGroup()
  .startGroup()
    .literal("{")
    .startNamedGroup("sCookwareQuantity")
      .anyCharacter().zeroOrMore().lazy()
    .endGroup()
    .literal("}")
  .endGroup().optional()
  .toRegExp();

const timer = createRegex()
  .literal("~")
  .startNamedGroup("timerName")
    .anyCharacter().zeroOrMore().lazy()
  .endGroup()
  .literal("{")
  .startNamedGroup("timerQuantity")
    .anyCharacter().oneOrMore().lazy()
  .endGroup()
  .startGroup()
    .literal("%")
    .startNamedGroup("timerUnit")
      .anyCharacter().oneOrMore().lazy()
    .endGroup()
  .endGroup().optional()
  .literal("}")
  .toRegExp()

export const tokensRegex = new RegExp(
  [
    multiwordIngredient,
    singleWordIngredient,
    multiwordCookware,
    singleWordCookware,
    timer,
  ]
    .map((r) => r.source)
    .join("|"),
  "gu",
);

export const commentRegex = createRegex()
  .literal("--")
  .anyCharacter().zeroOrMore()
  .global()
  .toRegExp();

export const blockCommentRegex = createRegex()
  .whitespace().zeroOrMore()
  .literal("[-")
  .anyCharacter().zeroOrMore().lazy()
  .literal("-]")
  .whitespace().zeroOrMore()
  .global()
  .toRegExp();

export const shoppingListRegex = createRegex()
  .literal("[")
  .startNamedGroup("name")
    .anyCharacter().oneOrMore()
  .endGroup()
  .literal("]")
  .newline()
  .startNamedGroup("items")
    .anyCharacter().zeroOrMore().lazy()
  .endGroup()
  .startGroup()
    .newline().newline()
      .or()
    .endAnchor()
  .endGroup()
  .global()
  .toRegExp()

export const rangeRegex = createRegex()
  .startAnchor()
  .digit().oneOrMore()
  .startGroup()
  .anyOf(".,/").exactly(1)
    .digit().oneOrMore()
  .endGroup().optional()
  .literal("-")
  .digit().oneOrMore()
  .startGroup()
    .anyOf(".,/").exactly(1)
    .digit().oneOrMore()
  .endGroup().optional()
  .endAnchor()
  .toRegExp()

export const numberLikeRegex = createRegex()
  .startAnchor()
  .digit().oneOrMore()
  .startGroup()
    .anyOf(".,/").exactly(1)
    .digit().oneOrMore()
  .endGroup().optional()
  .endAnchor()
  .toRegExp()

export const floatRegex = createRegex()
  .startAnchor()
  .digit().oneOrMore()
  .startGroup()
    .anyOf(".").exactly(1)
    .digit().oneOrMore()
  .endGroup().optional()
  .endAnchor()
  .toRegExp()