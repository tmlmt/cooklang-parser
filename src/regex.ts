import { createRegex } from "human-regex";

export const metadataRegex = createRegex()
  .literal("---").newline()
  .startCaptureGroup().anyCharacter().zeroOrMore().optional().endGroup()
  .newline().literal("---")
  .dotAll().toRegExp();

export const scalingMetaValueRegex = (varName: string): RegExp => createRegex()
  .startAnchor()
  .literal(varName)
  .literal(":")
  .anyOf("\\t ").zeroOrMore()
  .startCaptureGroup()
    .startCaptureGroup()
      .notAnyOf(",\\n").oneOrMore()
    .endGroup()
    .startGroup()
      .literal(",")
      .whitespace().zeroOrMore()
      .startCaptureGroup()
        .anyCharacter().oneOrMore()
      .endGroup()
    .endGroup().optional()
  .endGroup()
  .endAnchor()
  .multiline()
  .toRegExp()

const nonWordChar = "\\s@#~\\[\\]{(,;:!?"
const nonWordCharStrict = "\\s@#~\\[\\]{(,;:!?|"

export const ingredientWithAlternativeRegex = createRegex()
  .literal("@")
  .startNamedGroup("ingredientModifiers")
    .anyOf("@\\-&?").zeroOrMore()
  .endGroup().optional()
  .startNamedGroup("ingredientRecipeAnchor")
    .literal("./")
  .endGroup().optional()
  .startGroup()
    .startGroup()
      .startNamedGroup("mIngredientName")
        .notAnyOf(nonWordChar).oneOrMore()
        .startGroup()
          .whitespace().oneOrMore().notAnyOf(nonWordChar).oneOrMore()
        .endGroup().oneOrMore()
      .endGroup()
      .positiveLookahead("\\s*(?:\\{[^\\}]*\\}|\\([^)]*\\))")
    .endGroup()
    .or()
    .startNamedGroup("sIngredientName")
      .notAnyOf(nonWordChar).zeroOrMore()
      .notAnyOf("\\."+nonWordChar)
    .endGroup()
  .endGroup()
  .startGroup()
    .literal("{")
    .startNamedGroup("ingredientQuantityModifier")
      .literal("=").exactly(1)
    .endGroup().optional()
    .startNamedGroup("ingredientQuantity")
      .startGroup()
        .notAnyOf("}|%").oneOrMore()
      .endGroup().optional()
      .startGroup()
        .literal("%")
        .notAnyOf("|}").oneOrMore().lazy()
      .endGroup().optional()
      .startGroup()
        .literal("|")
        .notAnyOf("}").oneOrMore().lazy()
      .endGroup().zeroOrMore()
    .endGroup()
    .literal("}")
  .endGroup().optional()
  .startGroup()
    .literal("(")
    .startNamedGroup("ingredientPreparation")
      .notAnyOf(")").oneOrMore().lazy()
    .endGroup()
    .literal(")")
  .endGroup().optional()
  .startGroup()
    .literal("[")
    .startNamedGroup("ingredientNote")
      .notAnyOf("\\]").oneOrMore().lazy()
    .endGroup()
    .literal("]")
  .endGroup().optional()
  .startNamedGroup("ingredientAlternative")
    .startGroup()
      .literal("|@")
      .startGroup()
        .anyOf("@\\-&?").zeroOrMore()
      .endGroup().optional()
      .startGroup()
        .literal("./")
      .endGroup().optional()
      .startGroup()
        .startGroup()
          .startGroup()
            .notAnyOf(nonWordChar).oneOrMore()
            .startGroup()
              .whitespace().oneOrMore().notAnyOf(nonWordChar).oneOrMore()
            .endGroup().oneOrMore()
          .endGroup()
          .positiveLookahead("\\s*(?:\\{[^\\}]*\\}|\\([^)]*\\))")
        .endGroup()
        .or()
        .startGroup()
          .notAnyOf(nonWordChar).oneOrMore()
        .endGroup()
      .endGroup()
      .startGroup()
        .literal("{")
        .startGroup()
          .literal("=").exactly(1)
        .endGroup().optional()
        .startGroup()
          .notAnyOf("}%").oneOrMore()
        .endGroup().optional()
        .startGroup()
          .literal("%")
          .startGroup()
            .notAnyOf("}").oneOrMore().lazy()
          .endGroup()
        .endGroup().optional()
        .literal("}")
      .endGroup().optional()
      .startGroup()
        .literal("(")
        .startGroup()
          .notAnyOf(")").oneOrMore().lazy()
        .endGroup()
        .literal(")")
      .endGroup().optional()
      .startGroup()
        .literal("[")
        .startGroup()
          .notAnyOf("\\]").oneOrMore().lazy()
        .endGroup()
        .literal("]")
      .endGroup().optional()
    .endGroup().zeroOrMore()
  .endGroup()
  .toRegExp();

export const quantityAlternativeRegex = createRegex()
  .startNamedGroup("ingredientQuantityValue")
    .notAnyOf("}|%").oneOrMore()
  .endGroup().optional()
  .startGroup()
    .literal("%")
    .startNamedGroup("ingredientUnit")
      .notAnyOf("|}").oneOrMore()
    .endGroup()
  .endGroup().optional()
  .startNamedGroup("ingredientAltQuantity")
    .startGroup()
      .literal("|")
      .notAnyOf("}").oneOrMore()
    .endGroup().zeroOrMore()
  .endGroup()
  .toRegExp()
  
export const ingredientWithGroupKeyRegex = createRegex()
  .literal("@|")
  .startNamedGroup("gIngredientGroupKey")
    .notAnyOf(nonWordCharStrict).oneOrMore()
  .endGroup()
  .literal("|")
  .startNamedGroup("gIngredientModifiers")
    .anyOf("@\\-&?").zeroOrMore()
  .endGroup().optional()
  .startNamedGroup("gIngredientRecipeAnchor")
    .literal("./")
  .endGroup().optional()
  .startGroup()
    .startGroup()
      .startNamedGroup("gmIngredientName")
        .notAnyOf(nonWordChar).oneOrMore()
        .startGroup()
          .whitespace().oneOrMore().notAnyOf(nonWordChar).oneOrMore()
        .endGroup().oneOrMore()
      .endGroup()
      .positiveLookahead("\\s*(?:\\{[^\\}]*\\}|\\([^)]*\\))")
    .endGroup()
    .or()
    .startNamedGroup("gsIngredientName")
      .notAnyOf(nonWordChar).zeroOrMore()
      .notAnyOf("\\."+nonWordChar)
    .endGroup()
  .endGroup()
  .startGroup()
    .literal("{")
    .startNamedGroup("gIngredientQuantityModifier")
      .literal("=").exactly(1)
    .endGroup().optional()
    .startNamedGroup("gIngredientQuantity")
      .startGroup()
        .notAnyOf("}|%").oneOrMore()
      .endGroup().optional()
      .startGroup()
        .literal("%")
        .notAnyOf("|}").oneOrMore().lazy()
      .endGroup().optional()
      .startGroup()
        .literal("|")
        .notAnyOf("}").oneOrMore().lazy()
      .endGroup().zeroOrMore()
    .endGroup()
    .literal("}")
  .endGroup().optional()
  .startGroup()
    .literal("(")
    .startNamedGroup("gIngredientPreparation")
      .notAnyOf(")").oneOrMore().lazy()
    .endGroup()
    .literal(")")
  .endGroup().optional()
  .toRegExp()

export const ingredientAliasRegex = createRegex()
  .startAnchor()
  .startNamedGroup("ingredientListName")
    .notAnyOf("|").oneOrMore()
  .endGroup()
  .literal("|")
  .startNamedGroup("ingredientDisplayName")
    .notAnyOf("|").oneOrMore()
  .endGroup()
  .endAnchor()
  .toRegExp();

export const cookwareRegex = createRegex()
  .literal("#")
  .startNamedGroup("cookwareModifiers")
    .anyOf("\\-&?").zeroOrMore()
  .endGroup()
  .startGroup()
    .startGroup()
      .startNamedGroup("mCookwareName")
        .notAnyOf(nonWordChar).oneOrMore()
        .startGroup()
          .whitespace().oneOrMore().notAnyOf(nonWordChar).oneOrMore()
        .endGroup().oneOrMore()
      .endGroup().positiveLookahead("\\s*(?:\\{[^\\}]*\\})")
    .endGroup()
    .or()
    .startNamedGroup("sCookwareName")
      .notAnyOf(nonWordChar).zeroOrMore()
      .notAnyOf("\\."+nonWordChar)
    .endGroup()
  .endGroup()
  .startGroup()
    .literal("{")
    .startNamedGroup("cookwareQuantity")
      .anyCharacter().zeroOrMore().lazy()
    .endGroup()
    .literal("}")
  .endGroup().optional()
  .toRegExp();

const timerRegex = createRegex()
  .literal("~")
  .startNamedGroup("timerName")
    .anyCharacter().zeroOrMore().lazy()
  .endGroup()
  .literal("{")
  .startNamedGroup("timerQuantity")
    .anyCharacter().oneOrMore().lazy()
  .endGroup()
  .startGroup()
    .literal("%")
    .startNamedGroup("timerUnit")
      .anyCharacter().oneOrMore().lazy()
    .endGroup()
  .endGroup().optional()
  .literal("}")
  .toRegExp()

export const tokensRegex = new RegExp(
  [
    ingredientWithAlternativeRegex,
    ingredientWithGroupKeyRegex,
    cookwareRegex,
    timerRegex,
  ]
    .map((r) => r.source)
    .join("|"),
  "gu",
);

export const commentRegex = createRegex()
  .literal("--")
  .anyCharacter().zeroOrMore()
  .global()
  .toRegExp();

export const blockCommentRegex = createRegex()
  .literal("[-")
  .anyCharacter().zeroOrMore().lazy()
  .literal("-]")
  .whitespace().zeroOrMore()
  .global()
  .toRegExp();

export const shoppingListRegex = createRegex()
  .literal("[")
  .startNamedGroup("name")
    .anyCharacter().oneOrMore()
  .endGroup()
  .literal("]")
  .newline()
  .startNamedGroup("items")
    .anyCharacter().zeroOrMore().lazy()
  .endGroup()
  .startGroup()
    .newline().newline()
      .or()
    .endAnchor()
  .endGroup()
  .global()
  .toRegExp()

export const rangeRegex = createRegex()
  .startAnchor()
  .digit().oneOrMore()
  .startGroup()
  .anyOf(".,/").exactly(1)
    .digit().oneOrMore()
  .endGroup().optional()
  .literal("-")
  .digit().oneOrMore()
  .startGroup()
    .anyOf(".,/").exactly(1)
    .digit().oneOrMore()
  .endGroup().optional()
  .endAnchor()
  .toRegExp()

export const numberLikeRegex = createRegex()
  .startAnchor()
  .digit().oneOrMore()
  .startGroup()
    .anyOf(".,/").exactly(1)
    .digit().oneOrMore()
  .endGroup().optional()
  .endAnchor()
  .toRegExp()

export const floatRegex = createRegex()
  .startAnchor()
  .digit().oneOrMore()
  .startGroup()
    .anyOf(".").exactly(1)
    .digit().oneOrMore()
  .endGroup().optional()
  .endAnchor()
  .toRegExp()